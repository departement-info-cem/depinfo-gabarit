# ğŸ§ª TP2 â€“ Mini-systÃ¨me dâ€™inventaire

---

## ğŸ¯ Objectif du TP2

BÃ¢tir, en console C#, une gestion de l'inventaire du personnage
### Inventaire
- ğŸ‘¤ **Un personnage** avec minimum :
  - un **nom**
  - une **force** (force = poids maximal transportable)
- ğŸ› ï¸ **Une liste dâ€™Ã©quipement** (description, prix, poids, effet)
- ğŸ’ **Un sac Ã  dos** de taille fixe contenant des indices vers la liste dâ€™Ã©quipement
- ğŸ“œ **Un menu interactif** qui permet :
  - dâ€™acheter des items  
  - dâ€™ajouter des items au sac  
  - tout en respectant **la bourse** et **la limite de poids**

  ![Inventaire](_02-tp2/Inventaire.png)

## ğŸ”¹ Progression

### Partie 1 â€“ Inventaire
1. Initialiser le personnage  
2. DÃ©finir les constantes et la liste dâ€™Ã©quipement  
3. ImplÃ©menter les petites fonctions (*getters*)  
4. GÃ©rer le sac Ã  dos  
5. ImplÃ©menter lâ€™achat  
6. Construire le menu dâ€™Ã©quipement  

### Bonus â€“ facultatif
7. AmÃ©lioration de lâ€™affichage (facultatif)  

## Ã‰tape 1 â€” Personnage

### 1ï¸âƒ£ DÃ©clarer les variables globales

```csharp
static string gNomPersonnage = "";
static int gForce = 10;
static int gBourse = 20;
```

---

### 2ï¸âƒ£ Dans Main

Appeler la fonction `InitialiserPersonnage()` :

```csharp
static void Main(string[] args)
{
    InitialiserPersonnage();
}
```

---

### 3ï¸âƒ£ Fonction InitialiserPersonnage

CrÃ©e la fonction `InitialiserPersonnage` :

```csharp
static void InitialiserPersonnage()
{
    // Ici on a le choix :
    // 1. On peut rÃ©utiliser notre code fait au TP1
    // 2. ou initialiser simplement les variables 'gNomPersonnage' et 'gForce'

   
    
}
```

---

### 4ï¸âƒ£ Fonction Tests

CrÃ©e une fonction `Tests` que tu utiliseras pour vÃ©rifier chaque nouvelle fonction que tu crÃ©eras.

```csharp
static void Tests()
{
    Console.WriteLine($"Nom : {gNomPersonnage}");
    Console.WriteLine($"Force : {gForce}");
    Console.WriteLine($"Bourse : {gBourse} po");
}
```

Appelle-la aussi dans `Main` :

```csharp
static void Main(string[] args)
{
    InitialiserPersonnage();
    Tests();
}
```



### âœ… **RÃ©sultat attendu**  
Ton programme affiche le personnage gÃ©nÃ©rÃ© avec son nom, sa force et sa bourse de dÃ©part.


## Ã‰tape 2 â€” DÃ©finir les constantes et la liste dâ€™Ã©quipement

### 1ï¸âƒ£ Constantes

On commence par dÃ©finir des constantes pour reprÃ©senter :  

- **Valeurs invalides** (quand un prix ou un poids nâ€™existe pas)  
- **Colonnes de la liste dâ€™Ã©quipement** (pour extraire description, prix, poids, effet)

```csharp
const int INVALIDE = -1;               // prix ou poids invalide
const string DESC_INVALIDE = "INVALIDE"; // description invalide

const int EQUIP_DESC = 0;  // Exemple : "Ã‰pÃ©e"
const int EQUIP_PRIX = 1;  // Exemple : 5 po
const int EQUIP_POIDS = 2; // Exemple : 2,5 Kg
const int EQUIP_EFFET = 3; // Exemple : "Attaque +3", "Points de vie +5"
```

---

### 2ï¸âƒ£ Liste dâ€™Ã©quipement

On crÃ©e un tableau de chaÃ®nes de caractÃ¨res (`string[]`).  
Chaque item est reprÃ©sentÃ© par une ligne avec le format suivant :

```
"Nom;Prix;Poids;Effet"
```

Exemple enrichi avec des **emojis Windows** ğŸ‰ :

```csharp
// ğŸ‘‡ Liste d'Ã©quipement enrichie + emojis Windows
static string[] gListeEquipement = {
    "ğŸ—¡ï¸ Ã‰pÃ©e;5; 6,5 ;Attaque +3",
    "ğŸ§ª Potion de vie;4; 0,5 ;Points de vie +5",
    "ğŸ¥– Ration;2;4,2;Points de vie +4",
    "ğŸ›¡ Bouclier en bois;6;7,0;DÃ©gÃ¢ts -2",
    "ğŸ¯ Arc court;7;2,0;Initiative",
    "ğŸ¹ Carquois;3;1,0;-",
    "ğŸ”¦ Torche;1;0,4;Annule pÃ©nalitÃ© de pÃ©nombre",
    "ğŸ§¥ Cape magique;3;1,2;Esquive 25%",
    "ğŸ’ Anneau cabossÃ©;2;0,1;Mana x 2"
};
```

---

### 3ï¸âƒ£ VÃ©rification

Ajoute un appel dans la fonction `Tests()` pour vÃ©rifier que les items sont bien enregistrÃ©s :  

```csharp
static void Tests()
{
    Console.WriteLine("=== Liste dâ€™Ã©quipement ===");
    for (int i = 0; i < gListeEquipement.Length; i++)
    {
        Console.WriteLine($"Item brut : {gListeEquipement[i]}");
    }
}
```

---

âœ… **RÃ©sultat attendu** :  
Quand tu exÃ©cutes `Tests()`, la console doit afficher la liste brute des items, par exemple :

```
=== Liste dâ€™Ã©quipement ===
Item brut : ğŸ—¡ï¸ Ã‰pÃ©e;5; 6,5 ;Attaque +3
Item brut : ğŸ§ª Potion de vie;4; 0,5 ;Points de vie +5
Item brut : ğŸ¥– Ration;2;4,2;Points de vie +4
...
```
---

## Ã‰tape 3 â€” ImplÃ©menter les petites fonctions (*getters*)

### ğŸ¯ Objectif

CrÃ©er des fonctions qui permettent **dâ€™accÃ©der aux informations dâ€™un item** dans la liste dâ€™Ã©quipement.  
Ces fonctions (*getters*) simplifient le code et Ã©vitent de rÃ©pÃ©ter la logique de dÃ©coupage (`Split`) dans tout le programme.

---

### 1ï¸âƒ£ Les getters Ã  Ã©crire

- `ObtenirPrixEquipement(int indexItem)` â†’ retourne le **prix** dâ€™un item.  
- `ObtenirPoidsEquipement(int indexItem)` â†’ retourne le **poids** dâ€™un item.  
- `ObtenirDescriptionEquipement(int indexItem)` â†’ retourne la **description** (nom) dâ€™un item.  
- `ObtenirEffetEquipement(int indexItem)` â†’ retourne lâ€™**effet** dâ€™un item.  

---

### 2ï¸âƒ£ Instructions gÃ©nÃ©rales

Chaque getter doit :

1. VÃ©rifier si lâ€™index est valide (entre `0` et `gListeEquipement.Length - 1`)  
   - Si invalide â†’ retourner `INVALIDE` (ou `DESC_INVALIDE` pour la description).

2. RÃ©cupÃ©rer la ligne correspondante dans `gListeEquipement`.  
   - Exemple : `string item = gListeEquipement[indexItem];`

3. DÃ©couper la chaÃ®ne en utilisant `.Split(';')`.  
   - Cela donne un tableau de sous-chaÃ®nes.  
   - Exemple : `string[] infos = item.Split(';');`

4. Retourner la bonne valeur selon la constante :  
   - `EQUIP_PRIX` â†’ prix (convertir en `int`)  
   - `EQUIP_POIDS` â†’ poids (convertir en `double`)  
   - `EQUIP_DESC` â†’ description (string)  
   - `EQUIP_EFFET` â†’ effet (string)

---

### 3ï¸âƒ£ Pseudo-code : Exemple pour le prix

```pseudo
fonction ObtenirPrixEquipement(indexItem)
    si indexItem < 0 ou indexItem >= longueur(gListeEquipement)
        retourner INVALIDE

    item = gListeEquipement[indexItem]
    infos = item.Split(';')
    prixTexte = infos[EQUIP_PRIX]
    prixNombre = convertir_en_int(prixTexte)
    retourner prixNombre
fin fonction
```

---

### 4ï¸âƒ£ Test rapide

Dans la fonction `Tests()`, affiche les infos de tous les items :

```csharp
static void Tests()
{
    for (int i = 0; i < gListeEquipement.Length; i++)
    {
        Console.WriteLine(
            $"{ObtenirDescriptionEquipement(i)} " +
            $"- {ObtenirPrixEquipement(i)} po " +
            $"- {ObtenirPoidsEquipement(i)} Kg " +
            $"- Effet : {ObtenirEffetEquipement(i)}"
        );
    }
}
```

---

âœ… **RÃ©sultat attendu** :  
La console doit afficher une liste lisible avec description, prix, poids **et effet** pour chaque item.


---

## Ã‰tape 4 â€” GÃ©rer le sac Ã  dos

### ğŸ¯ Objectif

Mettre en place les fonctions qui permettent de :

- ğŸ“¦ Afficher le contenu du sac Ã  dos  
- ğŸ” Trouver une case libre dans le sac  
- â• Ajouter un item dans le sac (en tenant compte de la place et du poids)  
- âš–ï¸ Calculer le poids total du sac  

---

### 1ï¸âƒ£ Constantes et dÃ©claration du sac

```csharp
const int VIDE = -1;      // Espace du sac vide
const int SAC_PLEIN = -1; // Sac plein

// Sac Ã  dos contenant des indices vers la liste d'Ã©quipement
static int[] gSacADos = { VIDE, VIDE, VIDE, VIDE, VIDE };
```

ğŸ‘‰ Le sac contient uniquement des **indices** pointant vers `gListeEquipement`.  

Exemple :  

- `gSacADos[0] = 2` â†’ premier item du sac est `gListeEquipement[2]` (Ration).  
- `gSacADos[1] = 0` â†’ deuxiÃ¨me item du sac est `gListeEquipement[0]` (Ã‰pÃ©e).  

---

### 2ï¸âƒ£ Afficher le sac Ã  dos

But : lister les items prÃ©sents, ou afficher "Aucun item" si le sac est vide.

```pseudo
fonction AfficherSacADos()
    afficher "Sac Ã  dos :"
    mettre une variable vide = vrai
    pour chaque case du sac
        si case â‰  VIDE
            afficher description de l'item
            vide = faux
    fin pour
    si vide == vrai
        afficher "Aucun item."
fin fonction
```

---

### 3ï¸âƒ£ Trouver un espace libre

```pseudo
fonction TrouverIndexEspaceLibreSacAdos()
    pour i de 0 Ã  longueur du sac
        si sac[i] == VIDE
            retourner i
    retourner SAC_PLEIN
fin fonction
```

---
### 4ï¸âƒ£ Calculer le poids du sac

```pseudo
fonction ObtenirPoidsDuSacADos()
    poidsTotal = 0
    pour i de 0 Ã  longueur du sac
        poids = ObtenirPoidsEquipement(sac[i])
        si poids != INVALIDE
            poidsTotal += poids
    retourner poidsTotal
fin fonction
```


---

### 5ï¸âƒ£ Ajouter un item au sac

But : vÃ©rifier les conditions avant dâ€™ajouter.

1. VÃ©rifier sâ€™il reste une case libre avec `TrouverIndexEspaceLibreSacAdos`.  
   - Si aucune â†’ message "Sac plein".

2. VÃ©rifier si le poids total + poids du nouvel item â‰¤ force du personnage.  
   - Si trop lourd â†’ message "Trop lourd".

3. Sinon, placer lâ€™item dans la case libre.

```pseudo
fonction AjouterAuSacADos(indexItem)
    indexLibre = TrouverIndexEspaceLibreSacAdos()
    si indexLibre == SAC_PLEIN
        afficher "Sac plein"
        retourner faux

    si PoidsDuSac() + PoidsItem(indexItem) > force
        afficher "Item trop lourd"
        retourner faux

    sac[indexLibre] = indexItem
    afficher "Item ajoutÃ© au sac"
    retourner vrai
fin fonction
```

---

### âœ… Test rapide

Dans la fonction `Tests()`, ajoutez :

```csharp
// Test 1 : sac vide
AfficherSacADos();
Console.WriteLine($"Poids du sac : {ObtenirPoidsDuSacADos()}");

// Test 2 : ajouter un item valide (ex. une potion)
AjouterAuSacADos(1); // Potion
AfficherSacADos();
Console.WriteLine($"Poids du sac : {ObtenirPoidsDuSacADos()}");

// Test 3 : ajouter plusieurs items
AjouterAuSacADos(0); // Ã‰pÃ©e
AjouterAuSacADos(2); // Ration
AfficherSacADos();
Console.WriteLine($"Poids du sac : {ObtenirPoidsDuSacADos()}");

// Test 4 : remplir le sac puis tenter dâ€™ajouter encore
for (int i = 0; i < 10; i++)
{
    AjouterAuSacADos(1); // Tentatives multiples
}
AfficherSacADos();
Console.WriteLine($"Poids du sac : {ObtenirPoidsDuSacADos()}");

```

---

### ğŸ¬ RÃ©sultat attendu

- **Test 1** â†’ "Aucun item" + poids = 0  
- **Test 2** â†’ Potion ajoutÃ©e, poids > 0  
- **Test 3** â†’ Plusieurs items listÃ©s, poids augmente  
- **Test 4** â†’ Messages "Sac plein" ou "Trop lourd" quand on dÃ©passe les limites  

## Ã‰tape 5 â€” Achat dâ€™un item

### ğŸ¯ Objectif

CrÃ©er une fonction `AcheterItem` qui permet :

- de vÃ©rifier si lâ€™item est valide  
- de vÃ©rifier si la bourse contient assez dâ€™or  
- dâ€™ajouter lâ€™item au sac Ã  dos si possible  
- de retirer le prix de la bourse lorsque lâ€™achat est rÃ©ussi  

---

### 1ï¸âƒ£ Ã‰tapes de lâ€™achat

1. VÃ©rifier la validitÃ© de lâ€™index  
   - Si invalide â†’ afficher `"Item invalide"` et retourner `false`.  

2. VÃ©rifier la bourse  
   - Si `gBourse < prix` â†’ afficher `"Pas assez de piÃ¨ces dâ€™or"` et retourner `false`.  

3. Tenter dâ€™ajouter lâ€™item au sac  
   - Si `AjouterAuSacADos` retourne `true`  
     - DÃ©duire le prix de `gBourse`  
     - Retourner `true`  

4. Sinon â†’ retourner `false`.  

---

### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction AcheterItem(indexItem)
    prix = ObtenirPrixEquipement(indexItem)

    si prix == INVALIDE
        afficher "Item invalide"
        retourner faux

    si gBourse < prix
        afficher "Pas assez d'or"
        retourner faux

    si AjouterAuSacADos(indexItem) == vrai
        gBourse -= prix
        retourner vrai

    retourner faux
fin fonction
```

---

### âœ… Tests rapides

Ajoutez dans `Tests()` :

```csharp
// Test 1 : acheter une potion
AcheterItem(1); // Potion
AfficherSacADos();
Console.WriteLine($"Bourse : {gBourse} po");

// Test 2 : acheter une Ã©pÃ©e
AcheterItem(0); // Ã‰pÃ©e
AfficherSacADos();
Console.WriteLine($"Bourse : {gBourse} po");

// Test 3 : tenter dâ€™acheter sans assez dâ€™or
gBourse = 1; // volontairement trop bas
AcheterItem(0); // Essaye dâ€™acheter une Ã©pÃ©e
Console.WriteLine($"Bourse : {gBourse} po");
```

---

### ğŸ¬ RÃ©sultat attendu

- **Test 1** â†’ Potion ajoutÃ©e au sac, bourse diminuÃ©e de 4 po  
- **Test 2** â†’ Ã‰pÃ©e ajoutÃ©e au sac, bourse diminuÃ©e de 5 po  
- **Test 3** â†’ Message `"Pas assez de piÃ¨ces dâ€™or"`, sac inchangÃ©, bourse inchangÃ©e  

## Ã‰tape 6 â€” Menu interactif dâ€™Ã©quipement

### ğŸ¯ Objectif

Mettre en place un **menu en console** qui permet au joueur :

- de voir la liste des Ã©quipements disponibles  
- de choisir un item Ã  acheter  
- de voir sa bourse et le poids total de son sac Ã  dos  
- de quitter lâ€™achat quand il le souhaite  

Ce menu boucle tant que le joueur ne choisit pas lâ€™option *Quitter*.

---

### 1ï¸âƒ£ Structure gÃ©nÃ©rale

```pseudo
fonction ChoisirEquipementDeDepart()
    rÃ©pÃ©ter indÃ©finiment
        afficher message de bienvenue + nom du personnage
        afficher la liste des items (description, prix, poids, effet)
        afficher option Quitter

        afficher la bourse et le poids du sac
        afficher le contenu du sac

        lire le choix de lâ€™utilisateur

        si choix == Quitter
            sortir de la boucle

        sinon si choix valide
            appeler AcheterItem(choix - 1)

        sinon
            afficher "Choix hors liste"
fin fonction
```

---

### 2ï¸âƒ£ Points importants

- Utiliser les getters (`ObtenirDescriptionEquipement`, `ObtenirPrixEquipement`, `ObtenirPoidsEquipement`, `ObtenirEffetEquipement`).  
- Le menu doit **se rÃ©pÃ©ter** jusquâ€™Ã  ce que lâ€™utilisateur choisisse *Quitter*.  
- Si le choix est invalide, afficher un message dâ€™erreur clair.  

---

### 3ï¸âƒ£ Exemple de sortie console

```
Bonjour Aragon !
Choisi un item parmi la liste suivante :

1. ğŸ—¡ï¸ Ã‰pÃ©e               5 po   6.5 Kg  Attaque +3
2. ğŸ§ª Potion de vie       4 po   0.5 Kg  Points de vie +5
3. ğŸ¥– Ration              2 po   4.2 Kg  Points de vie +4
4. ğŸ›¡ Bouclier en bois    6 po   7.0 Kg  DÃ©gÃ¢ts -2
...
10. Quitter

ğŸ’° Bourse : 20 po
ğŸ‹ï¸ Poids du sac : 0 Kg / 10 Kg

ğŸ’ Sac Ã  dos :
Aucun item.

â–¶  Choix :
```

---

### âœ… Tests rapides

Dans la fonction `Tests()` ou directement via `Main()` :

```csharp
ChoisirEquipementDeDepart();
```

- **Test 1** â†’ Entrer un nombre invalide â†’ message `"Choix hors liste"`.  
- **Test 2** â†’ Acheter une potion â†’ sac contient une potion, bourse diminuÃ©e.  
- **Test 3** â†’ Acheter trop dâ€™items â†’ messages `"Sac plein"` ou `"Trop lourd"`.  
- **Test 4** â†’ Choisir lâ€™option *Quitter* â†’ retour au programme principal.  

---

### ğŸ¬ RÃ©sultat attendu

Le joueur interagit avec un menu simple en console, peut acheter des items tant quâ€™il a de lâ€™or et de la place, et sort avec lâ€™option *Quitter*.



---

### ğŸ¯ Objectif

CrÃ©er un **menu interactif** permettant au joueur de se dÃ©placer dans le donjon jusquâ€™Ã  ce quâ€™il choisisse de quitter.

---


### 1ï¸âƒ£ Instructions

1. CrÃ©er une fonction `MenuNavigation()`.
2. Marquer la case de dÃ©part comme visitÃ©e (`donjonVisite[posX, posY] = true;`).
3. Dans une boucle infinie (`for(;;)` ou `while(true)`), faire :  
   - Afficher le donjon (`AfficherDonjon()`)  
   - Afficher les options de dÃ©placement (`AfficherOptionsDeplacement()`)  
   - Afficher lâ€™option `Q â†’ Quitter`  
   - Lire le choix de lâ€™utilisateur  
   - Si choix = `Q` â†’ sortir de la fonction  
   - Sinon â†’ appeler `DeplacerJoueur(choix)`  
4. RÃ©pÃ©ter tant que lâ€™utilisateur nâ€™a pas quittÃ©.

---

### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction MenuNavigation()
    marquer la case (posX, posY) comme visitÃ©e

    rÃ©pÃ©ter indÃ©finiment
        afficher donjon
        afficher options de dÃ©placement
        afficher "Q â†’ Quitter"

        lire le choix du joueur

        si choix == "Q"
            sortir de la boucle

        sinon
            DeplacerJoueur(choix)
fin fonction
```

---

### 3ï¸âƒ£ Test rapide

Ajoute dans `Main()` :

```csharp
MenuNavigation();
```

---

### ğŸ¬ RÃ©sultat attendu

- Le joueur voit le donjon et sa position (`ğŸ˜ƒ`).  
- Les salles visitÃ©es changent de couleur (ou Ã©tat).  
- Les options de dÃ©placement disponibles sâ€™affichent selon la position.  
- Entrer une direction valide â†’ dÃ©place le joueur.  
- Entrer `Q` â†’ quitte la navigation.  

# ğŸ¨ Bonus â€“ AmÃ©lioration de lâ€™affichage (Facultatif)

---
## Ã‰tape 7 â€” AmÃ©lioration de lâ€™affichage (Facultatif)
### ğŸ¯ Objectif

Rendre lâ€™affichage du menu et du sac Ã  dos plus agrÃ©able visuellement en utilisant :

- âœ… Les **emojis** et caractÃ¨res Unicode  
- âœ… Les **barres ASCII**  
- âœ… La **couleur** (`Console.ForegroundColor`)  
- âœ… Le **nettoyage dâ€™Ã©cran** (`Console.Clear()`)  
- âœ… Le **padding** pour aligner les colonnes  

Ces amÃ©liorations sont **facultatives** et nâ€™influencent pas la logique du programme.

---


### 1ï¸âƒ£ Activer les emojis et caractÃ¨res Ã©tendus

```csharp
// Activer les emojis et caractÃ¨res Ã©tendus (Windows)
Console.OutputEncoding = System.Text.Encoding.UTF8;
```

Cela permet dâ€™afficher des icÃ´nes comme ğŸ’, âš”, ğŸ’° directement dans la console.

---

### 2ï¸âƒ£ Barres ASCII dÃ©coratives

```csharp
// Design ASCII
static string gBar = "+===========================================================+";
static string gBarThin = "+-----------------------------------------------------------+";
```

ğŸ‘‰ Utilisez `Console.WriteLine(gBar);` pour encadrer le menu ou le contenu du sac.

---

### 3ï¸âƒ£ Nettoyer lâ€™Ã©cran avant dâ€™afficher le menu

```csharp
Console.Clear();
```

ğŸ‘‰ Cela permet de supprimer lâ€™affichage prÃ©cÃ©dent et de montrer uniquement le menu actuel.

---

### 4ï¸âƒ£ Couleur de texte

```csharp
Console.ForegroundColor = ConsoleColor.Yellow;
Console.WriteLine("Texte en jaune");

Console.ForegroundColor = ConsoleColor.Red;
Console.WriteLine("Erreur : pas assez de piÃ¨ces dâ€™or !");

Console.ResetColor();
```

ğŸ‘‰ Toujours remettre les couleurs par dÃ©faut avec `Console.ResetColor()`.

---

### 5ï¸âƒ£ Aligner les colonnes avec padding

```csharp
// Exemple dans une boucle dâ€™affichage des items
Console.Write($"{i + 1}. {ObtenirDescriptionEquipement(i),-20} ");
Console.Write($" {ObtenirPrixEquipement(i),4} po");
Console.Write($" {ObtenirPoidsEquipement(i),4} Kg");
Console.WriteLine($" {ObtenirEffetEquipement(i),-8}");
```

- `,-20` â†’ rÃ©serve 20 caractÃ¨res pour aligner les noms dâ€™items Ã  gauche.  
- `,4` â†’ rÃ©serve 4 caractÃ¨res, alignÃ©s Ã  droite (utile pour les nombres).  

ğŸ‘‰ RÃ©sultat : une liste bien alignÃ©e mÃªme si les noms/prix/poids ont des tailles diffÃ©rentes.

## ğŸ§¾ Grille de correction (TP2)

| Ã‰lÃ©ment de correction | BarÃ¨me | PondÃ©ration |
|--- | ---: | ---: | 
| Affichage de la liste d'Ã©quipement | 10 / 8 / 6 / 3 / 0 | 15 points |
| Affichage du sac Ã  dos | 10 / 8 / 6 / 3 / 0 | 20 points |
| Achat d'un item | 10 / 8 / 6 / 3 / 0 | 50 points |
| Fonctionnement du menu | 10 / 8 / 6 / 3 / 0 | 15 points |
| Bonus (Affichage avancÃ©) | 10 / 8 / 6 / 3 / 0 | 10 points |
| **Total** |  | **100 points** |

### âœ… BarÃ¨me

Le tableau ciâ€‘dessous dÃ©crit ce que signifient les notes 10 / 8 / 6 / 3 / 0 pour un Ã©lÃ©ment Ã©valuÃ©.

| Niveau | CritÃ¨res (description) | Score |
|---|---|---:|
| Excellent | Les critÃ¨res d'Ã©valuation sont atteints et le code est exemplaire : lisible, bien structurÃ©, sans bugs, commentaires appropriÃ©s et gestion des cas limites. | 10 |
| TrÃ¨s bien | La plupart des critÃ¨res d'Ã©valuation sont atteints. Quelques lacunes mineures n'empÃªchent pas la bonne exÃ©cution de la fonctionnalitÃ©. | 8 |
| Correct | Plusieurs lacunes sont constatÃ©es et nuisent partiellement Ã  l'application (bugs mineurs, code rÃ©pÃ©titif, validations incomplÃ¨tes). | 6 |
| Insuffisant | Les lacunes sont telles que l'application ne peut pas fonctionner convenablement (fonction manquante, grosse erreur logique, validations absentes). | 3 |
| Inexistant | Non rÃ©alisÃ© : la fonctionnalitÃ© est absente ou ne compile pas. | 0 |

