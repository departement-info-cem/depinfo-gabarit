---
toc_min_heading_level: 2
toc_max_heading_level: 3
---

# ğŸ§ª TP3 â€“ Super RPG Infini

---

## ğŸ¯ Objectif du TP3

BÃ¢tir, en console C#, un petit jeux en trois parties :

### Partie 1 â€“ Navigation dans un donjon
- ğŸ° **Un donjon 3x3** reprÃ©sentÃ© par une grille
- ğŸ‘£ **DÃ©placement du joueur** (Nord, Sud, Est, Ouest)
- âœ… **Suivi des salles visitÃ©es**
- ğŸ­ **Affichage de la position du joueur** et du donjon en console
- ğŸ”„ **Boucle de navigation** avec option *Quitter*
- ğŸ† **Fin de partie**

![Navigation](_02-tp2/Navigation.png)

---

### Partie 2 â€“ CrÃ©er de nouveaux donjons
- PrÃ©parer le fichier donjon.csv
- Charger le nouveau donjon

### Partie 3 â€“ Ã‰vÃ¨nements dans les salles du donjon
- ğŸ­ **Affichage avancÃ©e** du donjon et de la position du joueur
- Ã‰vÃ¨nements dans les salles du donjon
- RÃ©solution des Ã©vÃ¨nements
- Fin de la partie avancÃ©e

---


## ğŸ”¹ Progression

##### Partie 1 â€“ Donjon
1. DÃ©finir les variables et le tableau du donjon  
2. Afficher le donjon avec la position du joueur  
3. Proposer des dÃ©placements valides (N, S, E, O)  
4. Mettre Ã  jour la position et marquer les salles visitÃ©es
5. CrÃ©er un menu de navigation complet
6. Fin de la partie

---
## ğŸ° Partie 1 â€“ Navigation dans un donjon

---
### Ã‰tape 1 â€” DÃ©finir les variables et le tableau du donjon

#### ğŸ¯ Objectif

Mettre en place un **donjon simple sous forme de grille (3x3)** dans lequel le joueur pourra se dÃ©placer.  
Chaque salle est reprÃ©sentÃ©e par un emoji pour rendre lâ€™affichage plus visuel.

---


#### 1ï¸âƒ£ DÃ©finir le donjon

On utilise un **tableau Ã  2 dimensions (`string[,]`)** pour reprÃ©senter le donjon.  
Chaque case contient un symbole qui reprÃ©sente une salle.

```csharp
// Ajout d'un donjon (3x3)
static string[,] donjon = new string[3, 3]
{
    { "ğŸ—¿", "ğŸ’€", "ğŸ’" },
    { "ğŸ‘¹", "ğŸ§™â€", "ğŸ—" },
    { "ğŸšª", "ğŸ§Ÿ", "ğŸ‘º" }
};
```

ğŸ‘‰ Ici le donjon est une **grille de 3 lignes Ã— 3 colonnes**.  
Exemple visuel :

```
ğŸ—¿   ğŸ’€   ğŸ’
ğŸ‘¹   ğŸ§™â€   ğŸ—
ğŸšª   ğŸ§Ÿ   ğŸ‘º
```

---

#### 2ï¸âƒ£ Suivi des salles visitÃ©es

On doit savoir si une salle a dÃ©jÃ  Ã©tÃ© visitÃ©e par le joueur ou non.  
On crÃ©e donc un **tableau parallÃ¨le de boolÃ©ens (`true` ou `false`)** :

```csharp
// Pour savoir si une piÃ¨ce a Ã©tÃ© visitÃ©e ou non
static bool[,] donjonVisite = new bool[3, 3];
```

ğŸ‘‰ Au dÃ©part toutes les cases contiennent `false` (non visitÃ©es).  
On mettra `true` lorsquâ€™un joueur entre dans une salle.

---

#### 3ï¸âƒ£ Position du joueur

On garde la position du joueur avec deux entiers :

```csharp
// Position du joueur dans le donjon
static int positionLigne = 0, positionColonne = 0;
```

- `positionLigne` â†’ ligne (0 = premiÃ¨re ligne, 1 = deuxiÃ¨me, etc.)  
- `positionColonne` â†’ colonne (0 = premiÃ¨re colonne, 1 = deuxiÃ¨me, etc.)  

ğŸ‘‰ Au dÃ©part le joueur est placÃ© en haut Ã  gauche (0,0).

---

#### âœ… Test rapide

Ajoute un affichage temporaire dans `Tests()` :

```csharp
Console.WriteLine("=== Donjon initial ===");
for (int ligne = 0; ligne < donjon.GetLength(0); ligne++)
{
    for (int colonne = 0; colonne < donjon.GetLength(1); colonne++)
    {
        Console.Write(donjon[ligne, colonne] + " ");
    }
    Console.WriteLine();
}

Console.WriteLine($"Position du joueur : ({positionLigne},{positionColonne})");
```

#### ğŸ¬ RÃ©sultat attendu

```
=== Donjon initial ===
ğŸ—¿ ğŸ’€ ğŸ’ 
ğŸ‘¹ ğŸ§™â€ ğŸ— 
ğŸšª ğŸ§Ÿ ğŸ‘º 
Position du joueur : (0,0)
```

---

ğŸ‘‰ Prochaine Ã©tape : afficher le donjon **avec la position du joueur mise en Ã©vidence** (par exemple avec "ğŸ˜ƒ" Ã  la place de la case).

### Ã‰tape 2 â€” Afficher le donjon avec la position du joueur

#### ğŸ¯ Objectif

Mettre en place une fonction qui permet :

- dâ€™afficher le donjon (3x3) en console  
- de montrer la position du joueur avec un emoji distinct (ex. ğŸ˜ƒ)  
- de diffÃ©rencier les salles visitÃ©es et non visitÃ©es  

---

#### 1ï¸âƒ£ Instructions

1. Parcourir toutes les cases du donjon avec **deux boucles imbriquÃ©es** (une pour les lignes, une pour les colonnes).  
2. Pour chaque case :  
   - Si la position du joueur correspond Ã  la case (`positionLigne`, `positionColonne`) â†’ afficher un emoji spÃ©cial pour reprÃ©senter le joueur.  
   - Sinon â†’ afficher lâ€™emoji de la salle.  
3. Modifier la couleur ou le style selon si la salle a dÃ©jÃ  Ã©tÃ© visitÃ©e (`donjonVisite[ligne, colonne] == true`).  
4. Nâ€™oubliez pas de revenir Ã  la ligne aprÃ¨s chaque rangÃ©e pour bien afficher la grille 3x3.  
5. ğŸ’¡ Astuce : vous pouvez aussi changer la **couleur de fond** avec `Console.BackgroundColor` pour encore mieux diffÃ©rencier les cases.  

---

#### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction AfficherDonjon()
    pour ligne de 0 Ã  2
        pour colonne de 0 Ã  2
            si (ligne == positionLigne et colonne == positionColonne)
                afficher "emoji joueur"
            sinon si (donjonVisite[ligne, colonne] == vrai)
                afficher "emoji de la salle en mode visitÃ©"
            sinon
                afficher "emoji de la salle en mode non visitÃ©"
        fin pour
        saut de ligne dans la console
    fin pour
fin fonction
```

---

#### 3ï¸âƒ£ Test rapide

Dans votre fonction `Tests()` :  

- Marquez la salle de dÃ©part comme visitÃ©e (`donjonVisite[positionLigne, positionColonne] = true`).  
- Appelez `AfficherDonjon()`.  
- Simulez la visite dâ€™une autre salle en modifiant `donjonVisite[ligne, colonne]` et affichez de nouveau.  

---

#### ğŸ¬ RÃ©sultat attendu

- Le joueur apparaÃ®t avec un emoji distinct (ğŸ˜ƒ par exemple).  
- Les salles visitÃ©es apparaissent dans un style diffÃ©rent (ex. gris).  
- Les salles non visitÃ©es apparaissent normales (ex. cyan).  
- On peut aussi utiliser une **couleur de fond diffÃ©rente** pour mieux distinguer les cases.  
- La grille 3x3 du donjon est correctement affichÃ©e.  

---

### Ã‰tape 3 â€” Afficher les options de dÃ©placement

#### ğŸ¯ Objectif

Permettre au joueur de voir **dans quelles directions il peut se dÃ©placer** Ã  partir de sa position actuelle dans le donjon.

---

#### 1ï¸âƒ£ SchÃ©ma du donjon (coordonnÃ©es)

```
    (0, 0) â”€â”€â–º colonne

      â”‚
      â–¼
    ligne
```

- `positionLigne` â†’ position verticale (lignes)
- `positionColonne` â†’ position horizontale (colonnes)

---

#### 2ï¸âƒ£ Instructions

1. CrÃ©e une fonction `AfficherOptionsDeplacement()`.
2. VÃ©rifie la position actuelle du joueur avec `positionLigne` et `positionColonne`.
3. Si un dÃ©placement est possible, affiche la direction correspondante :
   - Nord (N) â†’ `positionLigne > 0`
   - Sud (S) â†’ `positionLigne < donjon.GetLength(0) - 1`
   - Ouest (O) â†’ `positionColonne > 0`
   - Est (E) â†’ `positionColonne < donjon.GetLength(1) - 1`
4. Si une direction nâ€™est pas possible (bord du donjon), ne rien afficher pour cette direction.

---

#### 3ï¸âƒ£ Pseudo-code

```pseudo
fonction AfficherOptionsDeplacement()
    si positionLigne > 0
        afficher "N â†’ Une salle au nord"

    si positionLigne < donjon.GetLength(0) - 1
        afficher "S â†’ Une salle au sud"

    si positionColonne > 0
        afficher "O â†’ Une salle Ã  lâ€™ouest"

    si positionColonne < donjon.GetLength(1) - 1
        afficher "E â†’ Une salle Ã  lâ€™est"
fin fonction
```

---

#### âœ… Test rapide

Ajoute dans ta fonction `Tests()` :

```csharp
AfficherOptionsDeplacement();
```

DÃ©place manuellement `positionLigne` et `positionColonne` pour vÃ©rifier que les directions affichÃ©es sont correctes selon la position.

---

#### ğŸ¬ RÃ©sultat attendu

- Si le joueur est en haut Ã  gauche `(0,0)` â†’ seulement Est et Sud sont possibles.  
- Si le joueur est au centre `(1,1)` â†’ toutes les directions sont possibles.  
- Si le joueur est en bas Ã  droite `(2,2)` â†’ seulement Nord et Ouest sont possibles.  

### Ã‰tape 4 â€” Menu de navigation

#### ğŸ¯ Objectif

CrÃ©er un **menu interactif** permettant au joueur de se dÃ©placer dans le donjon jusquâ€™Ã  ce quâ€™il choisisse de quitter.

---


#### 1ï¸âƒ£ Instructions

1. CrÃ©er une fonction `MenuNavigation()`.
2. Marquer la case de dÃ©part comme visitÃ©e (`donjonVisite[positionLigne, positionColonne] = true;`).
3. Dans une boucle infinie (`for(;;)` ou `while(true)`), faire :  
   - Afficher le donjon (`AfficherDonjon()`)  
   - Afficher les options de dÃ©placement (`AfficherOptionsDeplacement()`)  
   - Afficher lâ€™option `Q â†’ Quitter`  
   - Lire le choix de lâ€™utilisateur  
   - Si choix = `Q` â†’ sortir de la fonction  
   - Sinon â†’ appeler `DeplacerJoueur(choix)`  
4. RÃ©pÃ©ter tant que lâ€™utilisateur nâ€™a pas quittÃ©.

---

#### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction MenuNavigation()
    marquer la case (positionLigne, positionColonne) comme visitÃ©e

    rÃ©pÃ©ter indÃ©finiment
        afficher donjon
        afficher options de dÃ©placement
        afficher "Q â†’ Quitter"

        lire le choix du joueur

        si choix == "Q"
            sortir de la boucle

        sinon
            DeplacerJoueur(choix)

fin fonction
```

---

#### 3ï¸âƒ£ Test rapide

Ajoute dans `Main()` :

```csharp
MenuNavigation();
```

---

#### ğŸ¬ RÃ©sultat attendu

- Le joueur voit le donjon et sa position (`ğŸ˜ƒ`).  
- Les salles visitÃ©es changent de couleur (ou Ã©tat).  
- Les options de dÃ©placement disponibles sâ€™affichent selon la position.  
- Entrer une direction valide â†’ dÃ©place le joueur.  
- Entrer `Q` â†’ quitte la navigation.  


### Ã‰tape 5 â€” DÃ©placer le joueur

#### ğŸ¯ Objectif

Mettre Ã  jour la **position du joueur** dans le donjon en fonction du choix de direction, et marquer la nouvelle salle comme visitÃ©e.

---

#### 1ï¸âƒ£ Instructions

1. CrÃ©er une fonction `DeplacerJoueur(string choix)`.
2. VÃ©rifier la direction choisie (`N`, `S`, `O`, `E`).
3. Mettre Ã  jour `positionLigne` ou `positionColonne` seulement si le dÃ©placement est possible (ne pas sortir du donjon).
4. Si le choix est invalide â†’ afficher `"Choix invalide."`.
5. Marquer la nouvelle position comme **visitÃ©e** dans `donjonVisite`.

---

#### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction DeplacerJoueur(choix)
    si choix == "N" et positionLigne > 0
        positionLigne--
    sinon si choix == "S" et positionLigne < donjon.GetLength(0) - 1
        positionLigne++
    sinon si choix == "O" et positionColonne > 0
        positionColonne--
    sinon si choix == "E" et positionColonne < donjon.GetLength(1) - 1
        positionColonne++
    sinon
        afficher "Choix invalide"

    donjonVisite[positionLigne, positionColonne] = vrai
fin fonction
```

---

#### 3ï¸âƒ£ Test rapide

Ajoute dans ta fonction `Tests()` :

```csharp
positionLigne = 1; positionColonne = 1; // dÃ©part au centre
AfficherDonjon();

DeplacerJoueur("N"); // vers le nord
AfficherDonjon();

DeplacerJoueur("O"); // vers lâ€™ouest
AfficherDonjon();

DeplacerJoueur("X"); // choix invalide
```

---

#### ğŸ¬ RÃ©sultat attendu

- Le joueur (`ğŸ˜ƒ`) se dÃ©place dans le donjon selon les directions valides.  
- Si une case est revisitÃ©e â†’ elle reste marquÃ©e comme visitÃ©e (`donjonVisite[ligne, colonne] = true`).  
- Un choix invalide affiche `"Choix invalide."` et ne dÃ©place pas le joueur.  

### Ã‰tape 6 â€” Fin de la partie

#### ğŸ¯ Objectif

Valider que le joueur la position du jouer et regarder s'il a rÃ©cupÃ©rer la clÃ©.

---

#### 1ï¸âƒ£ Instructions
1. Ajouter une variable globale pour savoir le joueur possede la clÃ©
```csharp
// Devient true lorsqu'on est sur "ğŸ—"
static bool possedeCle = false;
```
ğŸ‘‰ Lorsque l'on se dÃ©place dans la salle contenant `"ğŸ—"`, la variable `possedeCle` devient Ã©gale Ã  `true`
2. CrÃ©er une fonction `FinDePartie()`.
3. VÃ©rifier si le joueur est sur la porte de sortie `"ğŸšª"`.
4. VÃ©rifier si le joueur a rÃ©cupÃ©rer la clÃ© pour dÃ©barrer la porte `"ğŸ—"`.
5. Si le joueur est sur la porte, **mais il n'est pas en possession de la clÃ©**, afficher `"La porte est verrouillÃ©e. Vous avez besoin de la clÃ©."`.
6. Si le joueur est sur la porte **et qu'il possede la clÃ©**, afficher un message de victoire `"  ğŸ‰ Victoire! ğŸ¥³  "` et **retourne la valeur `true`**.

---

#### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction FinDePartie()
    si donjon[positionLigne, positionColonne] != "ğŸšª"
        retourne faux
    
    si !possedeCle
        afficher "La porte est verrouillÃ©e. Vous avez besoin de la clÃ©."
        retourne faux
    sinon
        afficher "  ğŸ‰ Victoire! ğŸ¥³  "
        retourne vrai
fin fonction
```

---

#### âœ… Test rapide

Ajoute dans ta fonction `Tests()` :

```csharp
possedeCle = false;
positionLigne = 2; positionColonne = 0; // dÃ©part sur la porte
FinDePartie(); // On a besoin de la clÃ©

positionLigne = 0; positionColonne = 0; // une position diffÃ©rente de la porte
FinDePartie(); // On n'est pas sur la porte, la fonction n'affiche rien

possedeCle = true;
positionLigne = 2; positionColonne = 0; // dÃ©part sur la porte
FinDePartie(); // Victoire!
```

---

#### ğŸ¬ RÃ©sultat attendu

- Lorsque le joueur est sur une casse diffÃ©rente de `"ğŸšª"`, la fonction n'affiche rien et elle retourne `false`.
- Lorsque le joueur est sur une casse diffÃ©rente de `"ğŸšª"`, mais qu'il ne possÃ¨de pas la `"ğŸ—"`, la fonction affiche que la porte est barrÃ©e et elle retourne `false`.  
- Lorsque le joueur est sur la casse `"ğŸšª"` et qu'il possÃ¨ede la `"ğŸ—"`, la fonction affiche un message de victoire, elle retourne `true` et le jeu se termine (on quitte la boucle du menu de navigation).
:::danger Attention!
Tu devras placer la fonction FinDePartie() au bon endroit dans ta boucle du menu de navigation pour Ãªtre capable de quitter le seul lors de la victoire
:::
---

## ğŸ”¹ Progression

##### Partie 2 â€“ CrÃ©er de nouveaux donjons
1. PrÃ©parer le fichier donjon.csv
2. Charger le nouveau donjon

---
## ğŸ—ºï¸ Partie 2 â€“ CrÃ©er de nouveaux donjons

---
### Ã‰tape 1 â€” PrÃ©parer le fichier donjon.csv

#### ğŸ¯ Objectif

Mettre en place un **fichier csv (donjon.csv)** dans lequel le vous pourrez crÃ©er de nouvelles cartes pour votre jeu. 

---


#### 1ï¸âƒ£ DÃ©finir le donjon

On reprendra le donjon de base.

```csharp
static string[,] donjon = new string[3, 3]
{
    { "ğŸ—¿", "ğŸ’€", "ğŸ’" },
    { "ğŸ‘¹", "ğŸ§™â€", "ğŸ—" },
    { "ğŸšª", "ğŸ§Ÿ", "ğŸ‘º" }
};
```

On pourra ensuite le transformer en fichier csv
```
ğŸ—¿;ğŸ’€;ğŸ’
ğŸ‘¹;ğŸ§™â€;ğŸ—
ğŸšª;ğŸ§Ÿ;ğŸ‘º
```

Sauvegarder donjon.csv Ã  la **racine de votre projet** (dans le mÃªme dossier que Program.cs)
<Row>
<Column>

![Projet](_03-tp3/projet.png)

</Column>
<Column>

</Column>
</Row>

---

#### âœ… Test rapide

Ouvrir le fichier `donjon.csv` avec **Excel**.

### Ã‰tape 2 â€” Charger le nouveau donjon

#### ğŸ¯ Objectif

Lire le fichier donjon.csv au lancement de l'application et placer le donjon lu dans la variable `string[,] donjon`.

---


#### 1ï¸âƒ£ Instructions

1. CrÃ©er une fonction `ChargerDonjonCSV()`.
2. Trouver le chemin du projet.
3. Ouvrir le fichier donjon.csv.
4. Lire le contenu du fichier.
5. Assigner le contenu du fichier Ã  la variable `string[,] donjon`.

---

#### 2ï¸âƒ£ Pseudo-code

```pseudo
fonction ChargerDonjonCSV()
    chemin = chemin vers donjon.csv

    lignes = new List<string>();
    ouvrir le fichier

    tant que ce n'est pas la fin du fichier
        Lire une fichier
        ajouter la ligne Ã  la liste `lignes`
    fin tant que

    nbLignes = Compter le nombre de lignes
    nbColonnes = Compter le nombre de colonnes

    rÃ©initialiser donjon avec la bonne taille
    rÃ©initialiser donjonVisite avec la bonne taille

    pour chaque ligne

        rÃ©cupÃ©rer la ligne courante dans la liste
        // sÃ©parer les Ã©lÃ©ments de la ligne
        elements = ligne.split(";")

        pour chaque colonne
            assigner l'Ã©lÃ©ment Ã  la bonne case du donjon
        fin pour
    fin pour

    fermer le fichier
fin fonction
```

---

#### 3ï¸âƒ£ Trouver le chemin vers le fichier

Pour trouver le chemin du fichier donjon.csv, nous utiliserons l'emplacement de programme comme point de dÃ©part. Toutefois, le programme est exÃ©cuter dans le dossier bin/Debug/net8.0 si l'on utilise .net 8 ou sinon bin/Debug/net9.0 pour la version 9 de .net.
Nous devrons donc revenir vers l'arriÃ¨re de 3 dossiers en utilisant le chemin relatif.

<Row>
<Column>

![Projet](_03-tp3/fichier.png)

</Column>
<Column>

</Column>
</Row>

##### Comment faire

```csharp
// new DirectoryInfo() donne l'emplacement du programme compilÃ©
// donc le dossier_tp3/bin/Debug/net8.0/ ou encore dossier_tp3/bin/Debug/net9.0/ 
// on remonte de trois niveaux pour atteindre le dossier du projet
DirectoryInfo di = new DirectoryInfo("../../../");      
// On utilise di.FullName pour obtenir le chemin complet du dossier du projet
StreamReader objFichier = new StreamReader(di.FullName + "/donjon.csv");
```

---

#### 4ï¸âƒ£ Utiliser une liste `List`

##### RÃ©fÃ©rence

Vous pouvez vous rÃ©fÃ©rez au besoin Ã  la documention de [Notions C#](https://info.cegepmontpetit.ca/notions-csharp/documentation/liste-generique-list-t)

:::info C'est quoi une liste
- Une liste est une `collection` de variables ou d'objets. 
- Dans le contexte du cours de 1P6, la liste ressemble beaucoup Ã  un tableau 1D
    - **La diffÃ©rence** c'est que la **taille du tableau est fixe** dÃ¨s le dÃ©part, alors qu'une **liste s'agrandie** lorsqu'on lui ajoute un item. 
:::

##### CrÃ©er une liste
On crÃ©e une nouvelle liste avec le **mot clÃ©** `new` plus de dÃ©tail
```csharp
List<string> lignesDuFichier = new List<string>();
```
- `List` type utilisÃ© pour crÃ©er une liste
- `<string>` type de donnÃ©es contenu dans la liste
    - L'Ã©quivalent pour un tableau serait `string[]`
- `new List<string>()` crÃ©ation d'une nouvelle liste
    - L'Ã©quivalent pour un tableau serait `new string[taille]`
    - Pour le tableau `taille` doit Ãªtre connu dÃ¨s le dÃ©part

##### Ajouter des donnÃ©es

Il suffit d'utiliser la fonction `Add`
```csharp
List<string> liste = new List<string>();

liste.Add("nouveau texte dans la liste");
```

##### Lire les donnÃ©es

On peut lire les donner comme un tableau
```csharp
List<int> liste = new List<int>();
// ...
int deuxiemeElement = liste[1] // pour accÃ©der Ã  l'item Ã  l'index 1

// parcourir la liste pour accÃ©der aux Ã©lÃ©ments 1 Ã  1
for(int i = 0; i < liste.Length; i++) 
{
    int element  = liste[i];
}
```

##### Besoin d'en plus?

Pour avoir plus d'informations, pouvez vous rÃ©fÃ©rez Ã  la documention de [Notions C#](https://info.cegepmontpetit.ca/notions-csharp/documentation/liste-generique-list-t)

---

#### âœ… Test rapide

Ajoute dans `Tests()` :

```csharp

AfficherDonjon();
```
---

#### ğŸ¬ RÃ©sultat attendu

- Le nouveau donjon devrait pourvoir s'afficher correctement!


## ğŸ”¹ Progression

##### Partie 3 â€“ Ã‰vÃ¨nements
1. DÃ©clancher un Ã©vÃ¨nement en arrivant dans une salle.
3. Utiliser un item au besoin.
4. RÃ©soudre l'Ã©vÃ¨nement.
5. Fin de la partie par manque de PV.
## ğŸ—ºï¸ Partie 3 â€“ Ã‰vÃ¨nements dans les salles du donjon
### âš ï¸ Attention - Temps de travail
:::danger â€¼ï¸ Temps de travail! âš ï¸
**Attention**, la partie est plus longue que la partie 1 et la partie 2. Par contre, la partie 3 compte pour une moins grande partie de la note du travail.

>Partie 1 : 50 % de la note â†’ 30 % du temps
>
>Partie 2 : 30 % de la note â†’ 20 % du temps
>
>Partie 3 : **20 % de la note â†’ 50 % du temps**

La partie 3 est volontairement plus longue, alors il devrait Ãªtre "facile" de faire 80% du TP et les derniers 20% demandent 
beaucoup plus d'efforts. Ainsi, **il peut Ãªtre normal de ne pas complÃ©ter la totalitÃ© de la partie 3**.
:::

### Ã‰tape 1 â€” DÃ©clancher un Ã©vÃ¨nement

#### ğŸ¯ Objectif

Interagir avec les Ã©lÃ©ments du donjon.

---

#### 1ï¸âƒ£ Instructions

- Modifier la case de dÃ©part du donjon.
- CrÃ©er la fonction `GererEvenements`.
- Ajouter les diffÃ©rents Ã©vÃ¨nements.
- CrÃ©er la fonction `RechercherEquipementDansSac`.
- Utiliser un item au besoin.
- CrÃ©er la fonction `Combat`

---

#### 2ï¸âƒ£ Modifier la case de dÃ©part
Assurez-vous que la case de dÃ©part du donjon (0,0) soit un case vide `""`

```csharp
static string[,] donjon = new string[3, 3]
{
    { "", "ğŸ’€", "ğŸ’" },
    { "ğŸ‘¹", "ğŸ§™â€", "ğŸ—" },
    { "ğŸšª", "ğŸ§Ÿ", "ğŸ‘º" }
};
```

Ou encore pour un CSV
```
;ğŸ’€;ğŸ’
ğŸ‘¹;ğŸ§™â€;ğŸ—
ğŸšª;ğŸ§Ÿ;ğŸ‘º
```

#### 3ï¸âƒ£ CrÃ©er `GererEvenements`
Cette fonction vous servera Ã  dÃ©terminer quel Ã©vÃ¨ment se produit Ã  l'arrivÃ©e dans la salle.

##### Pseudo-Code
```pseudo
fonction GererEvenements()
    
    string evenement = la salle du donjon selon la position du joueur

    selon (evenement)
        cas "ğŸ§™":
            // faire le bon traitement selon l'Ã©vÃ¨nement

        // ...
        // faire le traitement de chaque Ã©vÃ¨nement
        // ...

        cas "":
            rien faire
        defaut:
            // ...
            

fin fonction
```

#### 4ï¸âƒ£ Liste des Ã©vÃ¨nements

<table>
    <tr>
        <th>Texte</th>
        <th>Ã‰vÃ¨nement</th>
    </tr>
    <tr>
        <td> `"ğŸ—"` </td>
        <td> Le personnage rÃ©cupÃ¨re la clÃ© </td>
    </tr>
    <tr>
        <td> `"ğŸšª"` </td>
        <td>      
```pseudo
Si le personnage a la clÃ©
    Fin du jeu
Sinon 
    Afficher "La porte est verrouillÃ©e. Vous avez besoin de la clÃ©."
````
        </td>
    </tr>
    <tr>
        <td> `"ğŸ§™"` </td>
        <td>      
```pseudo
Si le personnage n'est pas un mage
    mettre le nombre de PV de l'ennemi Ã  5
    Lancer un combat
````
        </td>
    </tr>
    <tr>
        <td> `"ğŸ¥·"` </td>
        <td>      
```pseudo
Si le personnage n'est pas un voleur
    mettre le nombre de PV de l'ennemi Ã  10
    Lancer un combat
````
        </td>
    </tr>
    <tr>
        <td> `"ğŸ¦¹"` </td>
        <td>      
```pseudo
Si le personnage n'est pas un guerrier
    mettre le nombre de PV de l'ennemi Ã  15
    Lancer un combat
````
        </td>
    </tr>
    <tr>
        <td> `"ğŸï¸"` </td>
        <td> Le personnage a trouvÃ© une oasis, il **gagne 5 pv** </td>
    </tr>
    <tr>
        <td> `" "` </td>
        <td>      
```pseudo
bool possedeTorche = RegarderDansSac(torche)
Si le personnage n'a pas de torche
    Afficher "Il fait trop sombre ici. Outch vous heurtez un mur et perdez 2 points de vie."
    retirer 2 pv au personnage.
````
        </td>
    </tr>
    <tr>
        <td> `""` </td>
        <td> On ne fait rien </td>
    </tr>
    <tr>
        <td> Tous les autres cas </td>
        <td> 
```pseudo
mettre le nombre de PV de l'ennemi Ã  10
Lancer un combat
````
        </td>
    </tr>
</table>

---

#### 5ï¸âƒ£ CrÃ©er la fonction `RechercherEquipementDansSac`

##### DÃ©finir les constantes requises
```csharp
const int EPEE = 0;
const int POTION = 1;
const int RATION = 2;
const int BOUCLIER = 3;
const int ARC_COURT = 4;
const int TORCHE = 6;
const int CAPE = 7;
```

##### MÃ©thode alternative
On peut utiliser un `enum`, les enums servent Ã  regrouper des constantes
```csharp
enum Equipement
{
    EPEE = 0,
    POTION = 1,
    RATION = 2,
    BOUCLIER = 3,
    ARC_COURT = 4,
    TORCHE = 6,
    CAPE = 7
}
```

La diffÃ©rence sera lors de l'utilisation
```csharp
// Avec une constante
bool possedeTorche = RechercherEquipementDansSac(TORCHE);
// Avec l'enum
bool possedeTorche = RechercherEquipementDansSac((int)Equipement.TORCHE);
```

##### Pseudo-code
```pseudo
fonction RechercherEquipementDansSac(equipementRecherche)

    pour i de 0 Ã  taille de gSacADos
        indexEquipement = gSacADos[i]
        si indexEquipement est Ã©gal Ã  equipementRecherche
            retourner VRAI
    fin pour

    retourner FAUX
fin fonction
```

#### 6ï¸âƒ£ CrÃ©er la mÃ©thode `Combat``
Ajouter un variable globale pour les points de vie de l'ennemi
```csharp
static int ennemiPV = 10;
```

CrÃ©er la fonction `Combat()`, pour l'instant nous ne ferons qu'afficher un message pour nos tests.
```csharp
static void Combat()
{
    Console.WriteLine("DÃ©but d'un combat contre un ennemi avec " + ennemiPV + " points de vie");
}
```

---

#### âœ… Test rapide

Ajouter dans `Tests()` :

```csharp
donjon = new string[3, 3]
{
    { "", "ğŸšª", "ğŸ—" },
    { "ğŸ§™", "ğŸ¥·", "ğŸ¦¹" },
    { "ğŸ‘º", "ğŸï¸", " " }
};

classe = 'V';

for (int rangee = 0; rangee < donjon.GetLength(0); rangee++)
{
    for (int colonne = 0; colonne < donjon.GetLength(1); colonne++)
    {
        position_rangee = rangee;
        position_colonne = colonne;
        GererEvenements();
    }
}

classe = 'M';
position_rangee = 1;
position_colonne = 0;
GererEvenements(); // Rien ne s'affiche
position_rangee = 1;
position_colonne = 1;
GererEvenements();
classe = 'G';
position_rangee = 2;
position_colonne = 2;
GererEvenements(); // Rien ne s'affiche

position_rangee = 0;
position_colonne = 1;
GererEvenements(); // Fin du jeu
Console.WriteLine("Victoire : " + finDuJeu);

```
---

#### ğŸ¬ RÃ©sultat attendu

```bash
La porte est verrouillÃ©e. Vous avez besoin de la clÃ©.
DÃ©but d'un combat contre un ennemi avec 5 points de vie
DÃ©but d'un combat contre un ennemi avec 15 points de vie
DÃ©but d'un combat contre un ennemi avec 10 points de vie
Vous avez trouvÃ© une oasis! Vos points de vie augmentent de 5.
DÃ©but d'un combat contre un ennemi avec 10 points de vie
Victoire : True
```

---

### Ã‰tape 2 â€” Faire les combats
#### ğŸ¯ Objectif

Interagir avec les Ã©lÃ©ments du donjon.

---

#### 1ï¸âƒ£ Instructions

- CrÃ©er la fonction `MenuCombat`.
    - Afficher les bonnes options de combat selon nos items
    - Afficher les bonnes options selon le status du combat
- Lancer un dÃ©
- Lire le choix du joueur
- Utiliser des items
    - Appliquer les effets des items
    - CrÃ©er la fonction `RetirerEquipementDansSac`
    - Consommer des potions et des rations
- RÃ©soudre le "round" de combat
    - Ajouter ou Enlever les PV au joueur
    - Enlever les PV Ã  l'ennemi
    - Quitter le combat

---

#### 2ï¸âƒ£ `MenuCombat()`

```pseudo
fonction MenuCombat
    possedePotion = RechercherEquipementDansSac(POTION);
    possedeRation = RechercherEquipementDansSac(RATION);

    Afficher les PV du joueur
    Afficher les PV de l'ennemi
    Afficher "Options de combat:"

    Si l'ennemi a des PV
        Afficher "A â†’ Attaquer"
        Afficher "F â†’ Fuir"
    Si le joueur possede une potion
        Afficher "P â†’ Utiliser une potion de vie"
    Si le joueur possede une ration
        Afficher "R â†’ Manger une ration"
    Si l'ennemi n'a plus de PV
        Afficher "Q â†’ Quitter"

fin fonction
```

#### 3ï¸âƒ£ Options `"A â†’ Attaquer"`

| Valeur de base | Modificateur Ã‰pÃ©e | Modificateur Intelligence |
| -------------- | ----------------- | ------------------------- |
| Le rÃ©sultat d'un jet de dÃ© | +3 Ã  la valeur du dÃ© | +1 Ã  la valeur du dÃ© pour chaque tranche de 5 d'intelligence |

##### Pseudo-Code
```pseudo
degatsJoueur = jet de dÃ©

Si le joueur possede l'Ã©pÃ©e
    augmenter degatsJoueur de 3;

modifIntelligence = intelligence / 5
augmenter degatsJoueur de la valeur de modifIntelligence;
retire degatsJoueur de ennemiPV
Afficher les dÃ©gÃ¢ts infligÃ©es Ã  l'ennemi
```

##### Exemple
```
ğŸ² â†’ Donne un valeur de 5
dÃ©gats = 5
ğŸ—¡ï¸ â†’ Le joueur possÃ¨de l'Ã©pÃ©e
dÃ©gats = 5 + 3 = 8
ğŸ§  â†’ Le personnage a 18 d'intelligence
modifIntelligence = 18 / 5 = 3
dÃ©gats = 8 + 3 = 11
Le joueur inflige 11 de dÃ©gÃ¢ts Ã  l'ennemi
```

#### 4ï¸âƒ£ Options `"F â†’ Fuir"`

Pour fuir le combat, il faudra avoir un valeur de fuite d'au moins 12

| Valeur de base | Modificateur Vitesse | Modificateur Cape |
| -------------- | ----------------- | ------------------------- |
| Le rÃ©sultat d'un jet de dÃ© | la valeur du dÃ© * la vitesse du personnage | +25% Ã  la valeur de fuite |


##### Pseudo-Code
```pseudo
valeurDeFuite = jet de dÃ©

si le joueur possede la cape
    augmenter valeurDeFuite de 25%;

Multiplier valeurDeFuite * vitesse
si la valeurDeFuite est plus grande que le requis pour fuire (12)
    fin du combat/
```

#### 5ï¸âƒ£ Options `"P â†’ Utiliser une potion de vie"` et `"R â†’ Manger une ration"`

C'est deux options fonctionnent de la mÃªme faÃ§on. Vous devrez crÃ©er la fonction `RetirerEquipementDansSac` pour consommÃ© un item.
- Une potion donne 5 PV au joueur
- Une ration donne 4 PV au joueur


##### Pseudo-Code (pour une potion)
```pseudo
Si le joueur a une potion
    augmenter le nombre de PV du jouer de 5
    Afficher "Vous utilisez une potion de vie et regagnez 5 points de vie."
    RetirerEquipementDansSac(POTION)
Sinon
    Afficher "Vous n'avez pas de potion de vie."
```

#### 6ï¸âƒ£ Options `"Q â†’ Quitter"`

On termine le combat et on revient au donjon.

Le personnage peut maintenant se dÃ©placer dans le donjon.

#### 7ï¸âƒ£ DÃ©roulement du `Combat`

##### Les Ã©tapes
Pour chaque ronde de combat
1. Lancer un dÃ©
2. Choisir parmis les options de combat
    - Appliquer les effets du choix
3. Appliquer les dÃ©gÃ¢ts ennemis
    - Appliquer les effets des items
    - Appliquer les effets des choix
4. RÃ©pÃ©ter Ã  partir de l'Ã©tape 1 tant que le combat n'est pas terminÃ©.
---

##### Pseudo-code pour le combat
```pseudo
fonction Combat()
    finDuCombat = FAUX
    Random generateur = new Random();

    tant que finDuCombat est faux

        MenuCombat();

        Lire le choix du joueur
        int de = generateur.Next(1, 7);        

        finDuCombat = RondeCombat(de, choix);

fin fonction
```

##### Pseudo-code pour une ronde de combat
Pour chaque ronde de combat, on retourna `true` si c'est la fin du combat et `false` si le combat doit se poursuivre.

```pseudo
fonction RondeCombat(de, choix)

    const int REQUIS_FUIR = 12;

    possedeBouclier = RechercherEquipementDansSac(BOUCLIER)
    possedeArcCourt = RechercherEquipementDansSac(ARC_COURT)
    possedeEpee = RechercherEquipementDansSac(EPEE)
    possedeCape = RechercherEquipementDansSac(CAPE)
    possedePotion = RechercherEquipementDansSac(POTION)
    possedeRation = RechercherEquipementDansSac(RATION)

    // L'ennemi est en vie au dÃ©but de la ronde
    bool ennemiVivant = ennemiPV > 0;

    selon le choix
        cas "A"
            Attaquer
        cas "F"
            Tenter de fuir
            si la fuite est reussie
                retourner VRAI
        cas "P"
            Prendre une potion
        cas "R"
            Prendre une ration
        cas "Q":
            retourner VRAI
        cas par dÃ©faut
            Afficher "Choix invalide."

    si ennemiVivant
        degatsEnnemi = 3;
        si le joueur possede le bouclier
            diminiuer degatsEnnemi de 2

        si l'ennemi n'a plus de PV et que le joueur possede l'arc court
            mettre degatsEnnemi Ã  0 // Le personnage ne recevra pas de dÃ©gats
    
    diminuer les PV du joueur de la valeur de degatsEnnemi
    afficher $"L'ennemi vous inflige {degatsEnnemi} points de dÃ©gÃ¢ts."
    
    si le joueur n'a plus de PV
        afficher un message de dÃ©faite (exemple "ğŸ˜¿ Vous n'avez plus de PV ğŸ˜¿")
        retourner VRAI

    retourner FAUX

fin fonction
```

#### âœ… Test rapide

Ici il y a beaucoup de facteurs en jeu, il serait donc pertinent de faire des **tests unitaires** pour valider tous les cas, toutefois les tests unitaires seront seulement couvert dans un cours de programmation en 2e session.

Nous ferons presque l'Ã©quivalent en testant tout les cas un Ã  un pour s'assurer que nos combats fonctionnnent. Nous testerons en utilisant la fonction `RondeCombat(de)`

Les cas que nous devrons tester une ronde avec
- ğŸ—¡ï¸ / pas d'Ã©pÃ©e
- ğŸ§  / 0 intelligence
- ğŸ¦¹ le personnage ne meurt pas / il tombe Ã  0 PV
- ğŸ‘¹ l'ennemi ne meurt pas / il tombe Ã  0 PV
- ğŸ›¡ï¸ / pas de bouclier
- ğŸ¹ et l'ennemi tombe Ã  0 PV
- On rÃ©ussie Ã  fuire / On Ã©choue notre tentative de fuite
- ğŸ§¥ / pas de cape magique
- On consomme une potion ğŸ§ª
- On consomme une potion une fois que l'ennemi n'a plus de PV
- On consomme une ration ğŸ¥–
---

**Ajouter dans `Tests()` :**

```csharp
TestCombat();
```

:::danger Noms de variables
Assurez vous d'avoir les mÃªmes noms de variables
```csharp
static int joueurPV = 2;
static int intelligence = 0;
static int vitesse = 1.0;

static int ennemiPV = 100;
```
:::

CrÃ©er `TestCombat()`
<details>

<summary>`TestCombat()`</summary>
```csharp
static void TestCombat()
{
    int espace_vide = -1;

    int[] sacADosVide = new int[] { espace_vide, espace_vide, espace_vide, espace_vide, espace_vide };
    int[] sacADosAvecEpee = new int[] { EPEE, espace_vide, espace_vide, espace_vide, espace_vide };
    int[] sacADosAvecArc = new int[] { ARC_COURT, espace_vide, espace_vide, espace_vide, espace_vide };
    int[] sacADosAvecCape = new int[] { CAPE, espace_vide, espace_vide, espace_vide, espace_vide };
    int[] sacADosAvecBouclier = new int[] { BOUCLIER, espace_vide, espace_vide, espace_vide, espace_vide };
    int[] sacADosAvecPotion = new int[] { POTION, espace_vide, espace_vide, espace_vide, espace_vide };
    int[] sacADosAvecRation = new int[] { RATION, espace_vide, espace_vide, espace_vide, espace_vide };

    Console.WriteLine("Test Attaque Normale: " + (AttaqueNormale() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Avec Ã‰pÃ©e: " + (AttaqueAvecEpee() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Avec Intelligence: " + (AttaqueAvecIntelligence() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Avec Ã‰pÃ©e et Intelligence: " + (AttaqueAvecEpeeEtIntelligence() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Ennemi 0 PV: " + (AttaqueEnnemi0PV() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Ennemi 0 PV Avec Arc: " + (AttaqueEnnemi0PVAvecArc() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Joueur 0 PV: " + (AttaqueJoueur0PV() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Attaque Avec Bouclier: " + (AttaqueAvecBouclier() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Fuite RÃ©ussie: " + (FuiteReussie() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Fuite Ã‰chec: " + (FuiteEchec() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Fuite Ã‰chec Avec Bouclier: " + (FuiteEchecAvecBouclier() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Fuite RÃ©ussie Avec Cape: " + (FuiteReussieAvecCape() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Fuite RÃ©ussie Avec Vitesse: " + (FuiteReussieAvecVitesse() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Fuite RÃ©ussie Avec Cape et Vitesse: " + (FuiteReussieAvecCapeEtVitesse() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Utilisation Potion: " + (UtiliserPotion() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Utilisation Potion Avec Ennemi Ã  0 PV: " + (UtiliserPotionEnnemi0PV() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Utilisation Ration: " + (UtiliserRation() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Utilisation Ration Avec Ennemi Ã  0 PV: " + (UtiliserRationEnnemi0PV() ? "PassÃ©" : "Ã‰chouÃ©"));
    Console.WriteLine("Test Quitter Combat: " + (Quitter() ? "PassÃ©" : "Ã‰chouÃ©"));

    Console.ReadLine();

    bool AttaqueNormale()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        RondeCombat(de, "A");

        return ennemiPV == 94; // DÃ©gÃ¢ts attendus: 6
    }

    bool AttaqueAvecEpee()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecEpee;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        RondeCombat(de, "A");

        return ennemiPV == 91; // DÃ©gÃ¢ts attendus: 9
    }

    bool AttaqueAvecIntelligence()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 20;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        RondeCombat(de, "A");

        return ennemiPV == 90; // DÃ©gÃ¢ts attendus: 10
    }

    bool AttaqueAvecEpeeEtIntelligence()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecEpee;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 20;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        RondeCombat(de, "A");

        return ennemiPV == 87; // DÃ©gÃ¢ts attendus: 13
    }

    bool AttaqueEnnemi0PV()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 1;

        int de = 6;

        bool finCombat = RondeCombat(de, "A");

        return !finCombat && ennemiPV <= 0 && joueurPV == 97;
    }

    bool AttaqueEnnemi0PVAvecArc()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecArc;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 1;

        int de = 6;

        bool finCombat = RondeCombat(de, "A");

        return !finCombat && ennemiPV <= 0 && joueurPV == 100;
    }

    bool AttaqueJoueur0PV()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 1;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        bool finCombat = RondeCombat(de, "A");

        return finCombat && joueurPV <= 0;
    }

    bool AttaqueAvecBouclier()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecBouclier;

        // Initialisation du joueur
        joueurPV = 2;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        bool finCombat = RondeCombat(de, "A");

        return !finCombat && joueurPV == 1; // DÃ©gÃ¢ts ennemis rÃ©duits de 2
    }

    bool FuiteReussie()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 12; // je sais, 12 ce n'est pas possible avec un dÃ© 6, mais c'est pour le test

        bool finCombat = RondeCombat(de, "F");

        return finCombat && joueurPV == 100 && ennemiPV == 100;
    }

    bool FuiteEchec()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 1;

        bool finCombat = RondeCombat(de, "F");

        return !finCombat && joueurPV == 97 && ennemiPV == 100;
    }

    bool FuiteEchecAvecBouclier()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecBouclier;

        // Initialisation du joueur
        joueurPV = 2;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 1;

        bool finCombat = RondeCombat(de, "F");

        return !finCombat && joueurPV == 1;
    }

    bool FuiteReussieAvecCape()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecCape;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 10; // je sais, 10 ce n'est pas possible avec un dÃ© 6, mais c'est pour le test

        bool finCombat = RondeCombat(de, "F");

        return finCombat && joueurPV == 100 && ennemiPV == 100;
    }

    bool FuiteReussieAvecVitesse()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosVide;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 3.0;

        ennemiPV = 100;

        int de = 4;

        bool finCombat = RondeCombat(de, "F");

        return finCombat && joueurPV == 100 && ennemiPV == 100;
    }

    bool FuiteReussieAvecCapeEtVitesse()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecCape;

        // Initialisation du joueur
        joueurPV = 100;
        intelligence = 0;
        vitesse = 2.5;

        ennemiPV = 100;

        int de = 4;

        bool finCombat = RondeCombat(de, "F");

        return finCombat && joueurPV == 100 && ennemiPV == 100;
    }

    bool UtiliserPotion()
    {
        // Initialisation du sac Ã  dos
        gSacADos = (int[])sacADosAvecPotion.Clone();

        // Initialisation du joueur
        joueurPV = 1;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        bool finCombat = RondeCombat(de, "P");

        return !finCombat && joueurPV == 3 && RechercherEquipementDansSac(POTION) == false; // Potion retirÃ©e et pv + 5 - 3 dÃ©gÃ¢ts ennemis
    }

    bool UtiliserPotionEnnemi0PV()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecPotion;

        // Initialisation du joueur
        joueurPV = 1;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 0;

        int de = 6;

        bool finCombat = RondeCombat(de, "P");

        return !finCombat && joueurPV == 6 && RechercherEquipementDansSac(POTION) == false; // Potion retirÃ©e et pv + 5
    }

    bool UtiliserRation()
    {
        // Initialisation du sac Ã  dos
        gSacADos = (int[])sacADosAvecRation.Clone();

        // Initialisation du joueur
        joueurPV = 1;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 100;

        int de = 6;

        bool finCombat = RondeCombat(de, "R");

        return !finCombat && joueurPV == 2 && RechercherEquipementDansSac(RATION) == false; // Ration retirÃ©e et pv + 4 - 3 dÃ©gÃ¢ts ennemis
    }

    bool UtiliserRationEnnemi0PV()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecRation;

        // Initialisation du joueur
        joueurPV = 1;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 0;

        int de = 6;

        bool finCombat = RondeCombat(de, "R");

        return !finCombat && joueurPV == 5 && RechercherEquipementDansSac(RATION) == false; // Potion retirÃ©e et pv + 4
    }

    bool Quitter()
    {
        // Initialisation du sac Ã  dos
        gSacADos = sacADosAvecRation;

        // Initialisation du joueur
        joueurPV = 1;
        intelligence = 0;
        vitesse = 1.0;

        ennemiPV = 0;

        int de = 6;

        bool finCombat = RondeCombat(de, "Q");

        return finCombat;
    }
    
}
```

</details>


#### ğŸ¬ RÃ©sultat attendu

:::note
Vous pourriez avec des Console.WriteLine() aux travers des tests
:::
```bash
Test Attaque Normale: PassÃ©
Test Attaque Avec Ã‰pÃ©e: PassÃ©
Test Attaque Avec Intelligence: PassÃ©
Test Attaque Avec Ã‰pÃ©e et Intelligence: PassÃ©
Test Attaque Ennemi 0 PV: PassÃ©
Test Attaque Ennemi 0 PV Avec Arc: PassÃ©
Test Attaque Joueur 0 PV: PassÃ©
Test Attaque Avec Bouclier: PassÃ©
Test Fuite RÃ©ussie: PassÃ©
Test Fuite Ã‰chec: PassÃ©
Test Fuite Ã‰chec Avec Bouclier: PassÃ©
Test Fuite RÃ©ussie Avec Cape: PassÃ©
Test Fuite RÃ©ussie Avec Vitesse: PassÃ©
Test Fuite RÃ©ussie Avec Cape et Vitesse: PassÃ©
Test Utilisation Potion: PassÃ©
Test Utilisation Potion Avec Ennemi Ã  0 PV: PassÃ©
Test Utilisation Ration: PassÃ©
Test Utilisation Ration Avec Ennemi Ã  0 PV: PassÃ©
Test Quitter Combat: PassÃ©
```

## ğŸ—ºï¸ Bonus

---

### ğŸ­ **Affichage avancÃ©e**

#### ğŸ¯ Objectif

Afficher le donjon par salle, cacher les salles qui n'ont pas Ã©tÃ© utilisÃ©s, utiliser notre personnage et transporter la clÃ©!

---

#### 1ï¸âƒ£ Instructions

1. CrÃ©er une fonction `AfficherSalle`.
2. CrÃ©er une constante pour la taille de la salle
    - `const int TAILLE_SALLE = 5;`
2. Position le correctement le curseur dans l'Ã©cran.
3. Afficher les murs de la salle.
4. Afficher le personnage.
5. Afficher la clÃ© avec le personnage.
6. Afficher le contenu de la salle.
7. CrÃ©er une fonction `AfficherDonjonPlusPlus`.

---

#### 2ï¸âƒ£ La logique
Ajouter 2 constantes pour le afficher les murs
```csharp
const char MUR_H = 'â”€';
const char MUR_V = 'â”‚';
```

##### Ã‰tape 1 - Dessiner les murs de la salle
Commencons par uniquement dessiner les murs de la salle.
Exemple pour une salle de 5x5

```mermaid
---
config:
    layout: elk
    elk:
        mergeEdges: true
---
block-beta
    columns 7
    A["(0,0)"] space:5 B["â¬…ï¸ axe des X"]
    space 11[" "] 21["â”€"] 31["â”€"] 41["â”€"] 51[" "] space
    space 12["|"] 22[" "] 32[" "] 42[" "] 52["|"] space
    space 13["|"] 23[" "] 33[" "] 43[" "] 53["|"] space
    space 14["|"] 24[" "] 34[" "] 44[" "] 54["|"] space
    space 15[" "] 25["â”€"] 35["â”€"] 45["â”€"] 55[" "] space
    C["â¬†ï¸ axe des Y"]space:5 D["(5,5)"]

    classDef label fill:none,stroke:none
    class A,B,C,D label

```
- `"â”€"` mur horinzontal
- `"|"` mur vertical

##### Ã‰tape 2 - Dessiner le contenu de la salle
Ensuite on dessine le contenu de la salle

```mermaid
---
config:
    layout: elk
    elk:
        mergeEdges: true
---
block-beta
    columns 7
    A["(0,0)"] space:5 B["â¬…ï¸ axe des X"]
    space 11[" "] 21["â”€"] 31["â”€"] 41["â”€"] 51[" "] space
    space 12["|"] 22["ğŸ§™ğŸ—"] 32[" "] 42[" "] 52["|"] space
    space 13["|"] 23[" "] 33["ğŸ‘¹"] 43[" "] 53["|"] space
    space 14["|"] 24[" "] 34[" "] 44[" "] 54["|"] space
    space 15[" "] 25["â”€"] 35["â”€"] 45["â”€"] 55[" "] space
    C["â¬†ï¸ axe des Y"]space:5 D["(5,5)"]

    classDef label fill:none,stroke:none
    class A,B,C,D label

```
- `"ğŸ‘¹"` le contenu de la salle en position (2,2)
- `"ğŸ§™"`le personnage en position (1,1) s'il est prÃ©sent dans la salle
-  `"ğŸ—"` la clÃ© Ã  cÃ´tÃ© du personnage s'il est en possession de la clÃ©

---

#### 3ï¸âƒ£ Pseudo-code
```pseudo
fonction AfficherSalle(rangee, colonne)
    
    depart_x = trouver la position de dÃ©part sur les X
    depart_y = trouver la position de dÃ©part sur les Y

    personnage = assigner le bon personnage

    pour i de 1 Ã  3
        Positionner le curseur Ã  (depart_x + i, depart_y)
        Dessiner un mur horizontal
        Positionner le curseur Ã  (depart_x + i, depart_y + taille_de_la_salle)
        Dessiner un mur horizontal
        Positionner le curseur Ã  (depart_x, depart_y + i)
        Dessiner un mur vertical
        Positionner le curseur Ã  (depart_x + taille_de_la_salle, depart_y + i)
        Dessiner un mur vertical

    milieu_x = depart_x + taille_de_la_salle / 2
    milieu_y = depart_y + taille_de_la_salle / 2

    Positionner le curseur Ã  (milieu_x , milieu_y)
    Dessiner le contenu de la salle

    Si les personnage est dans la salle
        Positionner le curseur Ã  (depart_x + 1, depart_y + 1)
        Afficher le personnage
        Si le personnage possÃ¨de la clÃ©
            Dessiner la clÃ©
fin fonction
```

#### 4ï¸âƒ£ Afficher le personnage
Ajouter 3 constantes pour afficher votre personnage dans le donjon
```csharp
const string MAGE = "ğŸ§™";
const string VOLEUR = "ğŸ¥·";
const string GUERRIER = "ğŸ¦¹";
```

Utiliser la bonne constante pour afficher votre personnage selon sa classe

#### 5ï¸âƒ£ Trouver la position de dÃ©part
ConsidÃ©rons que nos points de dÃ©part sont les coins suppÃ©rieur gauche de chaque de nos salles.

Si nous avons un donjon de 2x2 et notre constante `const int TAILLE_SALLE = 5;`, les diffÃ©rents points de dÃ©part seraient
 - (0, 0)
 - (5, 0)
 - (0, 5)
 - (5, 5)

Alors le parcours de notre donjon sera 
```pseudo
pour rangÃ©e de 0 Ã  nombre de rangÃ©es du donjon
    pour colonne de 0 Ã  nombre de colonnes du donjon
        AfficherSalle(rangÃ©e, colonne);
    fin pour
fin pour
```

Nous aurons donc les appels Ã  `AfficherSalle` suivant
- AfficherSalle(0,0)
- AfficherSalle(0,1)
- AfficherSalle(1,0)
- AfficherSalle(1,1)

ğŸ¤” En sachant que nos salles ont une taille de 5x5 cases dans la consoles, que **changer de colonne augmente l'axe des X** et que que **changer de colonne augmente l'axe des Y**
```csharpğŸˆ
int departX = ? * TAILLE_SALLE;
int departY = ? * TAILLE_SALLE;
```

---

#### 6ï¸âƒ£ Positionner le curseur de la console
Pour placer le curseur d'Ã©criture de la console Ã  un emplacement prÃ©cis, il suffit d'utiliser la fonction `Console.SetCursorPosition` et ensuite on Ã©crit avec `Console.Write`
```csharp
Console.SetCursorPosition(1,1);
Console.Write("ğŸ™€");
Console.SetCursorPosition(2,2);
Console.Write("ğŸˆ");
Console.SetCursorPosition(1,4);
Console.Write("ğŸ±");
```
RÃ©sultat
``` 

 ğŸ™€   ğŸ±
   ğŸˆ
```

---

#### 7ï¸âƒ£ CrÃ©er `AfficherDonjonPlusPlus`

CrÃ©er une nouvelle fonction `AfficherDonjonPlusPlus()`, nous n'utiliserons plus `AfficherDonjon()`

```pseudo

pour toutes les rangees de donjon
    pour toutes les colonnes de donjon
        AfficherSalle(rangee, colonne)
    fin pour
fin pour
```

---

#### âœ… Test rapide

Ajouter dans `Tests()` :

```csharp

AfficherDonjonPlusPlus()
```
---

#### ğŸ¬ RÃ©sultat attendu

- Le nouveau donjon devrait pourvoir s'afficher correctement!

